{"version":3,"sources":["index.js"],"names":["data","source","dragging","document","e","mousePos","x","y","d","reval","newConnector","nodes","connectors","index","onNodeStartMove","onNodeMove","onNewConnector","classNames","node","nodeHeader","nodeTitle","nodeContent","nodeInputWrapper","nodeInputList","nodeOutputWrapper","nodeOutputList","connector"],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA7BA;AA+BA;AACA;AACA;AAhCA;AAkCA;AACA;AACA;AAnCA;AAqCA;AACA;AACA;AAtCA;AAwCA;AACA;AACA;AAxCA;AA0CA;AACA;AACA;AACA;AACA;AACA;AAzBE;AAAmB;AA4BrB;AA5BqB;AA8BrB;AA3BI;AACEA;AACAC;AACAC;AAHW;AAiCjB;AA3BI;AACA;AAViB;AAWlB;AA8BH;AACA;AACA;AACA;AA9BIC;AACAA;AACD;AAgCH;AACA;AACA;AA/BIA;AACAA;AACD;AAiCH;AACA;AACA;AAhCI;AACD;AAkCH;AACA;AACA;AAjCIC;AACAA;AAmCJ;AArCiB;AAuCjB;AAjCI;AAmCJ;AAlCI;AAoCJ;AAlCI;AACEC;AACEC;AACAC;AAFQ;AADE;AAMf;AAoCH;AACA;AACA;AAnCI;AACD;AAqCH;AACA;AACA;AApCI;AACD;AAsCH;AACA;AACA;AArCI;AAuCJ;AArCIC;AACAA;AAuCJ;AArCI;AACD;AAuCH;AACA;AACA;AAtCI;AACD;AAwCH;AACA;AACA;AAvCI;AAyCJ;AAvCM;AACA;AACA;AACA;AACA;AAyCN;AAvCM;AACD;AACD;AACD;AAyCH;AACA;AACA;AAxCI;AA0CJ;AA3C2C;AAAA;AAAA;AA+C3C;AA/C2C;AAGvC;AAAsB;AAgD1B;AA/CM;AACE;AACD;AACCC;AACD;AAEF;AAVsC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWxC;AA8DH;AACA;AACA;AA7DI;AA+DJ;AAhE0B;AAAA;AAAA;AAoE1B;AApE0B;AAGtB;AAAwB;AAqE5B;AApEM;AACE;AACD;AACCA;AACD;AACF;AATqB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUvB;AAoFH;AACA;AACA;AAnFW;AAqFX;AApFI;AACA;AAsFJ;AApFI;AACA;AAsFJ;AApFI;AAsFJ;AApFM;AACA;AACA;AAsFN;AApFMC;AACE;AACA;AACA;AAHa;AAKhB;AAsFL;AApFI;AAsFJ;AApFI;AACE;AAAA;AACGC;AACC;AACE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAuFZ;AArFY;AAAa;AAAA;AACb;AAAY;AAAA;AACZ;AAAY;AAAA;AA6FxB;AA3FY;AAAkB;AAAA;AAClB;AAAqB;AAAA;AAvBhB;AAyBR;AAID;AAAA;AAAA;AACGC;AACC;AACA;AAgGZ;AA9FY;AACA;AAgGZ;AA9FY;AACE;AACA;AACA;AACA;AAJK;AAMR;AAGAF;AAjBH;AA/BF;AAqDH;AA4FH;AACA;AACA;AACA;AAxSqBG;AAGjBb;AACAc;AACAC;AACAC;AACAC;AACEC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AATgC;AALjB;AAwTrB;AACA","file":"index.js","sourcesContent":["import React from 'react';\nimport Node from './lib/Node';\nimport Spline from './lib/Spline';\nimport SVGComponent from './lib/SVGComponent';\n\nimport {computeOutOffsetByIndex, computeInOffsetByIndex} from './lib/util';\n\nexport default class index extends React.Component {\n\n  static propTypes = {\n    data: React.PropTypes.object,\n    onNodeStartMove: React.PropTypes.func,\n    onNodeMove: React.PropTypes.func,\n    onNewConnector: React.PropTypes.func,\n    classNames: React.PropTypes.shape({\n      node: React.PropTypes.string,\n      nodeHeader: React.PropTypes.string,\n      nodeTitle: React.PropTypes.string,\n      nodeContent: React.PropTypes.string,\n      nodeInputWrapper: React.PropTypes.string,\n      nodeInputList: React.PropTypes.string,\n      nodeOutputWrapper: React.PropTypes.string,\n      nodeOutputList: React.PropTypes.string,\n      connector: React.PropTypes.string,\n    }).isRequired,\n  }\n\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      data : this.props.data,\n      source : [],\n      dragging: false,\n    };\n\n    this.onMouseMove = this.onMouseMove.bind(this);\n    this.onMouseUp = this.onMouseUp.bind(this);\n  }\n\n  componentDidMount() {\n    document.addEventListener('mousemove', this.onMouseMove);\n    document.addEventListener('mouseup', this.onMouseUp);\n  }\n\n  componentWillUnmount() {\n    document.removeEventListener('mousemove', this.onMouseMove);\n    document.removeEventListener('mouseup', this.onMouseUp);\n  }\n\n  onMouseUp(e) {\n    this.setState({dragging:false});\n  }\n\n  onMouseMove(e) {\n    e.stopPropagation();\n    e.preventDefault();\n\n    const {svgComponent: {refs: {svg}}} = this.refs;\n\n    // Get svg element position to substract offset top and left\n    const svgRect = svg.getBoundingClientRect();\n\n    this.setState({\n      mousePos: {\n        x: e.pageX - svgRect.left,\n        y: e.pageY - svgRect.top,\n      },\n    });\n  }\n\n  handleNodeStart(nid) {\n    this.props.onNodeStartMove(nid);\n  }\n\n  handleNodeStop(nid, pos) {\n    this.props.onNodeMove(nid, pos);\n  }\n\n  handleNodeMove(index, pos) {\n    let d = this.state.data;\n\n    d.nodes[index].x = pos.left;\n    d.nodes[index].y = pos.top;\n\n    this.setState({data : d});\n  }\n\n  handleStartConnector(nid, outputIndex) {\n    this.setState({dragging:true, source:[nid,outputIndex] });\n  }\n\n  handleCompleteConnector(nid, inputIndex) {\n    if (this.state.dragging) {\n\n      let nodes = this.state.data.nodes;\n      let fromNode = this.getNodebyId(nodes, this.state.source[0]);\n      let fromPinName = fromNode.fields.out[this.state.source[1]].name;\n      let toNode = this.getNodebyId(nodes, nid);\n      let toPinName = toNode.fields.in[inputIndex].name;\n\n      this.props.onNewConnector(fromNode.nid, fromPinName, toNode.nid, toPinName);\n    }\n    this.setState({dragging:false});\n  }\n\n  computePinIndexfromLabel(pins, pinLabel) {\n    let reval = 0;\n\n    for (let pin of pins) {\n      if (pin.name === pinLabel) {\n        return reval;\n      } else {\n        reval++;\n      }\n\n    }\n  }\n\n  getNodebyId(nodes, nid) {\n    let reval = 0;\n\n    for (let node of nodes) {\n      if (node.nid === nid) {\n        return nodes[reval];\n      } else {\n        reval++;\n      }\n    }\n  }\n\n\n  render() {\n    let nodes = this.state.data.nodes;\n    let connectors = this.state.data.connections;\n\n    let i = 0;\n    let newConnector = null;\n\n    if (this.state.dragging) {\n\n      let sourceNode = this.getNodebyId(nodes, this.state.source[0]);\n      let connectorStart = computeOutOffsetByIndex(sourceNode.x, sourceNode.y, this.state.source[1]);\n      let connectorEnd = {x:this.state.mousePos.x, y:this.state.mousePos.y};\n\n      newConnector = <Spline\n        connectorClass={this.props.classNames.connector}\n        start={connectorStart}\n        end={connectorEnd}\n      />;\n    }\n\n    let splineIndex = 0;\n\n    return (\n      <div>\n        {nodes.map((node)=> {\n          return <Node\n            nodeClass={this.props.classNames.node}\n            nodeHeaderClass={this.props.classNames.nodeHeader}\n            nodeTitleClass={this.props.classNames.nodeTitle}\n            nodeContentClass={this.props.classNames.nodeContent}\n            nodeInputWrapperClass={this.props.classNames.nodeInputWrapper}\n            nodeInputListClass={this.props.classNames.nodeInputList}\n            nodeOutputWrapperClass={this.props.classNames.nodeOutputWrapper}\n            nodeOutputListClass={this.props.classNames.nodeOutputList}\n            index={i++} \n            nid={node.nid}\n            color=\"#000000\"\n            title={node.type}\n            inputs={node.fields.in}\n            outputs={node.fields.out}\n            pos={{x : node.x, y: node.y}}\n            key={node.nid} \n\n            onNodeStart={(nid)=>this.handleNodeStart(nid)}\n            onNodeStop={(nid, pos)=>this.handleNodeStop(nid, pos)}\n            onNodeMove={(index,pos)=>this.handleNodeMove(index,pos)}\n\n            onStartConnector={(nid, outputIndex)=>this.handleStartConnector(nid, outputIndex)}\n            onCompleteConnector={(nid, inputIndex)=>this.handleCompleteConnector(nid, inputIndex)}\n          />;\n        })}\n\n        {/* render our connectors */}\n\n        <SVGComponent height=\"100%\" width=\"100%\" ref=\"svgComponent\">\n          {connectors.map((connector)=> {\n            let fromNode = this.getNodebyId(nodes,connector.from_node);\n            let toNode = this.getNodebyId(nodes,connector.to_node);\n\n            let splinestart = computeOutOffsetByIndex(fromNode.x, fromNode.y, this.computePinIndexfromLabel(fromNode.fields.out, connector.from));\n            let splineend = computeInOffsetByIndex(toNode.x, toNode.y, this.computePinIndexfromLabel(toNode.fields.in, connector.to));\n\n            return <Spline\n              connectorClass={this.props.classNames.connector}\n              start={splinestart}\n              end={splineend}\n              key={splineIndex++}\n            />;\n          })}\n\n          {/* this is our new connector that only appears on dragging */}\n          {newConnector}\n\n        </SVGComponent>\n      </div>\n    );\n  }\n}\n"],"sourceRoot":"/source/"}