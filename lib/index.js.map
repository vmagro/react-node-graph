{"version":3,"sources":["index.js"],"names":["data","source","dragging","document","e","mousePos","x","y","d","reval","newConnector","nodes","connectors","index","onNodeStartMove","onNodeMove","onNewConnector","classNames","node","nodeHeader","nodeTitle","nodeContent","nodeInputWrapper","nodeInputList","nodeOutputWrapper","nodeOutputList","connector"],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA7BA;AA+BA;AACA;AACA;AAhCA;AAkCA;AACA;AACA;AAnCA;AAqCA;AACA;AACA;AAtCA;AAwCA;AACA;AACA;AAxCA;AA0CA;AACA;AACA;AACA;AACA;AACA;AAzBC;AAAmB;AA4BpB;AA5BoB;AA8BpB;AA3BE;AACCA;AACAC;AACAC;AAHY;AAiCf;AA3BE;AACA;AAVkB;AAWlB;AA8BF;AACA;AACA;AACA;AA9BEC;AACAA;AACA;AAgCF;AACA;AACA;AA/BEA;AACAA;AACA;AAiCF;AACA;AACA;AAhCE;AACA;AAkCF;AACA;AACA;AAjCEC;AACEA;AAmCJ;AArCgB;AAuChB;AAjCI;AAmCJ;AAlCI;AAoCJ;AAlCE;AACKC;AACEC;AACAC;AAFQ;AADD;AAMd;AAoCF;AACA;AACA;AAnCE;AACA;AAqCF;AACA;AACA;AApCE;AACA;AAsCF;AACA;AACA;AArCE;AAuCF;AArCEC;AACAA;AAuCF;AArCE;AACA;AAuCF;AACA;AACA;AAtCE;AACA;AAwCF;AACA;AACA;AAvCE;AAyCF;AAvCG;AACA;AACA;AACA;AACA;AAyCH;AAvCG;AACA;AACD;AACA;AAyCF;AACA;AACA;AAxCE;AA0CF;AA3C0C;AAAA;AAAA;AA+C1C;AA/C0C;AAGxC;AAAsB;AAgDxB;AA/CG;AACC;AACA;AACAC;AACA;AAED;AAVuC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWxC;AA8DF;AACA;AACA;AA7DE;AA+DF;AAhEyB;AAAA;AAAA;AAoEzB;AApEyB;AAGvB;AAAwB;AAqE1B;AApEG;AACC;AACA;AACAA;AACA;AACD;AATsB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUvB;AAoFF;AACA;AACA;AAnFU;AAqFV;AApFE;AACA;AAsFF;AApFE;AACA;AAsFF;AApFE;AAsFF;AApFG;AACA;AACA;AAsFH;AApFMC;AACE;AACA;AACA;AAHa;AAKlB;AAsFH;AApFE;AAsFF;AApFE;AACC;AAAA;AACEC;AACK;AACU;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAuFZ;AArFY;AAAa;AAAA;AACb;AAAY;AAAA;AACZ;AAAY;AAAA;AA6FxB;AA3FY;AAAkB;AAAA;AAClB;AAAqB;AAAA;AAvBhB;AAyBZ;AAID;AAAA;AAAA;AAEEC;AACA;AACA;AA+FN;AA7FM;AACA;AA+FN;AA7FY;AACE;AACP;AACA;AACA;AAJY;AAOb;AAGAF;AAnBF;AA/BD;AAuDD;AA0FF;AACA;AACA;AACA;AAxSqBG;AAGjBb;AACAc;AACAC;AACAC;AACAC;AACEC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AATgC;AALjB;AAwTrB;AACA","file":"index.js","sourcesContent":["import React from 'react';\nimport Node from './lib/Node';\nimport Spline from './lib/Spline';\nimport SVGComponent from './lib/SVGComponent';\n\nimport {computeOutOffsetByIndex, computeInOffsetByIndex} from './lib/util';\n\nexport default class index extends React.Component {\n\n  static propTypes = {\n    data: React.PropTypes.object,\n    onNodeStartMove: React.PropTypes.func,\n    onNodeMove: React.PropTypes.func,\n    onNewConnector: React.PropTypes.func,\n    classNames: React.PropTypes.shape({\n      node: React.PropTypes.string,\n      nodeHeader: React.PropTypes.string,\n      nodeTitle: React.PropTypes.string,\n      nodeContent: React.PropTypes.string,\n      nodeInputWrapper: React.PropTypes.string,\n      nodeInputList: React.PropTypes.string,\n      nodeOutputWrapper: React.PropTypes.string,\n      nodeOutputList: React.PropTypes.string,\n      connector: React.PropTypes.string,\n    }).isRequired,\n  }\n\n\tconstructor(props) {\n\t\tsuper(props);\n\n\t\tthis.state = {\n\t\t\tdata : this.props.data,\n\t\t\tsource : [],\n\t\t\tdragging: false\n\t\t}\n\n\t\tthis.onMouseMove = this.onMouseMove.bind(this);\n\t\tthis.onMouseUp = this.onMouseUp.bind(this);\n\t}\n\n\tcomponentDidMount() {\n\t\tdocument.addEventListener('mousemove', this.onMouseMove);\n\t\tdocument.addEventListener('mouseup', this.onMouseUp);\n\t}\n\n\tcomponentWillUnmount() {\n\t\tdocument.removeEventListener('mousemove', this.onMouseMove);\n\t\tdocument.removeEventListener('mouseup', this.onMouseUp);\n\t}\n\n\tonMouseUp(e) {\n\t\tthis.setState({dragging:false, });\n\t}\n\n\tonMouseMove(e) {\n\t\te.stopPropagation();\n  \t\te.preventDefault();\n\n  \t\tconst {svgComponent: {refs: {svg}}} = this.refs;\n\n  \t\t//Get svg element position to substract offset top and left \n  \t\tconst svgRect = svg.getBoundingClientRect();\n\n\t\tthis.setState({\n\t      mousePos: {\n\t        x: e.pageX - svgRect.left,\n\t        y: e.pageY - svgRect.top\n\t      }\n\t    });\n\t}\n\n\thandleNodeStart(nid) {\n\t\tthis.props.onNodeStartMove(nid);\n\t}\n\n\thandleNodeStop(nid, pos) {\n\t\tthis.props.onNodeMove(nid, pos);\n\t}\n\n\thandleNodeMove(index, pos) {\n\t\tlet d = this.state.data;\n\n\t\td.nodes[index].x = pos.left;\n\t\td.nodes[index].y = pos.top;\n\n\t\tthis.setState({data : d});\n\t}\n\n\thandleStartConnector(nid, outputIndex) {\n\t\tthis.setState({dragging:true, source:[nid,outputIndex] });\n\t}\n\n\thandleCompleteConnector(nid, inputIndex) {\n\t\tif (this.state.dragging) {\n\n\t\t\tlet nodes = this.state.data.nodes;\n\t\t\tlet fromNode = this.getNodebyId(nodes, this.state.source[0]);\n\t\t\tlet fromPinName = fromNode.fields.out[this.state.source[1]].name;\n\t\t\tlet toNode = this.getNodebyId(nodes, nid);\n\t\t\tlet toPinName = toNode.fields.in[inputIndex].name;\n\n\t\t\tthis.props.onNewConnector(fromNode.nid, fromPinName, toNode.nid, toPinName);\n\t\t}\n\t\tthis.setState({dragging:false});\n\t}\n\n\tcomputePinIndexfromLabel(pins, pinLabel) {\n\t\tlet reval = 0;\n\n\t\tfor (let pin of pins) {\n\t\t\tif (pin.name === pinLabel) {\n\t\t\t\treturn reval;\n\t\t\t} else {\n\t\t\t\treval++;\n\t\t\t}\n\n\t\t}\n\t}\n\n\tgetNodebyId(nodes, nid) {\n\t\tlet reval = 0;\n\n\t\tfor (let node of nodes) {\n\t\t\tif (node.nid === nid) {\n\t\t\t\treturn nodes[reval];\n\t\t\t} else {\n\t\t\t\treval++;\n\t\t\t}\n\t\t}\n\t}\n\n\n\trender() {\n\t\tlet nodes = this.state.data.nodes;\n\t\tlet connectors = this.state.data.connections;\n\n\t\tlet i = 0;\n\t\tlet newConnector = null;\n\n\t\tif (this.state.dragging) {\n\n\t\t\tlet sourceNode = this.getNodebyId(nodes, this.state.source[0]);\n\t\t\tlet connectorStart = computeOutOffsetByIndex(sourceNode.x, sourceNode.y, this.state.source[1]);\n\t\t\tlet connectorEnd = {x:this.state.mousePos.x, y:this.state.mousePos.y};\n\t\t\t\t\t\n      newConnector = <Spline\n        connectorClass={this.props.classNames.connector}\n        start={connectorStart}\n        end={connectorEnd}\n      />\n\t\t}\n\n\t\tlet splineIndex = 0;\n\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t{nodes.map((node)=> {\n          return <Node\n                    nodeClass={this.props.classNames.node}\n                    nodeHeaderClass={this.props.classNames.nodeHeader}\n                    nodeTitleClass={this.props.classNames.nodeTitle}\n                    nodeContentClass={this.props.classNames.nodeContent}\n                    nodeInputWrapperClass={this.props.classNames.nodeInputWrapper}\n                    nodeInputListClass={this.props.classNames.nodeInputList}\n                    nodeOutputWrapperClass={this.props.classNames.nodeOutputWrapper}\n                    nodeOutputListClass={this.props.classNames.nodeOutputList}\n    \t\t\t\t\t\t\t\tindex={i++} \n    \t\t\t\t\t\t\t\tnid={node.nid}\n    \t\t\t\t\t\t\t\tcolor=\"#000000\"\n    \t\t\t\t\t\t\t\ttitle={node.type}\n    \t\t\t\t\t\t\t\tinputs={node.fields.in}\n    \t\t\t\t\t\t\t\toutputs={node.fields.out}\n    \t\t\t\t\t\t\t\tpos={{x : node.x, y: node.y}}\n    \t\t\t\t\t\t\t\tkey={node.nid} \n\n    \t\t\t\t\t\t\t\tonNodeStart={(nid)=>this.handleNodeStart(nid)}\n    \t\t\t\t\t\t\t\tonNodeStop={(nid, pos)=>this.handleNodeStop(nid, pos)}\n    \t\t\t\t\t\t\t\tonNodeMove={(index,pos)=>this.handleNodeMove(index,pos)}\n    \t\t\t\t\t\t\t\t\n    \t\t\t\t\t\t\t\tonStartConnector={(nid, outputIndex)=>this.handleStartConnector(nid, outputIndex)}\n    \t\t\t\t\t\t\t\tonCompleteConnector={(nid, inputIndex)=>this.handleCompleteConnector(nid, inputIndex)}\n    \t\t\t\t\t\t\t\t/>\n\t\t\t\t})}\n\t\t\t\t\n\t\t\t\t{/* render our connectors */} \n\n\t\t\t\t<SVGComponent height=\"100%\" width=\"100%\" ref=\"svgComponent\">\n\n\t\t\t\t\t{connectors.map((connector)=> {\n\t\t\t\t\t\tlet fromNode = this.getNodebyId(nodes,connector.from_node);\n\t\t\t\t\t\tlet toNode = this.getNodebyId(nodes,connector.to_node);\n\n\t\t\t\t\t\tlet splinestart = computeOutOffsetByIndex(fromNode.x, fromNode.y, this.computePinIndexfromLabel(fromNode.fields.out, connector.from));\n\t\t\t\t\t\tlet splineend = computeInOffsetByIndex(toNode.x, toNode.y, this.computePinIndexfromLabel(toNode.fields.in, connector.to));\n\n            return <Spline\n              connectorClass={this.props.classNames.connector}\n\t\t\t\t\t\t\tstart={splinestart}\n\t\t\t\t\t\t\tend={splineend}\n\t\t\t\t\t\t\tkey={splineIndex++}\n\t\t\t\t\t\t/>\n\n\t\t\t\t\t})}\n\n\t\t\t\t\t{/* this is our new connector that only appears on dragging */}\n\t\t\t\t\t{newConnector}\n\n\t\t\t\t</SVGComponent>\n\t\t\t</div>\n\t\t);\n\t}\n}\n"],"sourceRoot":"/source/"}